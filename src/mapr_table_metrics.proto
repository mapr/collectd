syntax = "proto2";

package mapr.fs.tablemetrics;
option optimize_for = LITE_RUNTIME;


// latency histogram layout.
// buckets are [0-1), [1-2), ..., [10000-inf):
enum HistoBucketBoundary {
  bucket0  =     1;
  bucket1  =     2;
  bucket2  =     5;
  bucket3  =    10;
  bucket4  =    25;
  bucket5  =    50;
  bucket6  =   100;
  bucket7  =   250;
  bucket8  =   500;
  bucket9  =  1000;
  bucket10 =  2500;
  bucket11 =  5000;
  bucket12 = 10000;
}

enum MetricsConstants {
  IndexOfLastTableMetricsBucket = 13;
  // we will have IndexOfLastTableMetricsBucket + 1 buckets:
  // imagine there is only ONE bucket0 (with cutoff k). Its index, zero based,
  // is going to be zero. But we certainly have two buckets: [0 -- k) and
  // [k -- inf). QED.
}

message HistoBar {
  optional int64 index = 1;
  optional int64 count = 2;
}

// operations for which metrics are collected:
enum opType {
  TM_PUT = 0;          // Put
  TM_CHECKANDPUT = 1;  // CheckAndPut
  TM_UPDATEANDGET = 2; // JsonUpdateAndGet + UpdateAndGet
  TM_APPEND = 3;       // Append
  TM_INCREMENT = 4;    // Increment
  TM_GET = 5;          // MultiTableGet + Get
  TM_SCAN = 6;         // Scan
};

message RpcMetrics {
  optional opType op = 1;

  optional int64 count = 2;
  optional int64 wsizeBytes = 3;
  optional int64 rsizeBytes = 4;
  optional int64 writeRows = 5;
  optional int64 respRows = 6;
  optional int64 readRows = 7;

  repeated HistoBar latencyHisto = 8;
  // it is assertable that the sum of HistoBar::count for all bars of
  // latencyHisto is exactly .count of the containing RpcMetrics.
  // RpcMetrics::count is therefore redundant but we still keep it to
  // simplify our lives when consuming these metrics
}

// tmFidMsg is used for table metrics, and table metrics only. Only
// accidentially, it is numerically equivalent to FidMsg from common.proto.
message tmFidMsg {
  optional uint32 cid = 1;    // container-id
  optional uint32 cinum = 2;  // inode number within container
  optional uint32 uniq = 3;   // uniquifier
}

// The per table metrics structure that will be used only when audit wants to
// serialize the table metrics to the local audit files
// This structure needs to be in sync with TableMetrics defined in
// tablemetrics.h
// If this structure changes in any manner, the function
// TableMetricsAudit::ConvertAuditRecordToJson() has to be updated
message MetricsMsg {
  optional tmFidMsg table = 1;
  optional int64 timeStamp = 2;
  repeated RpcMetrics rpcMetrics = 3;
  optional int64 valueCacheLookups = 4;
  optional int64 valueCacheHits = 5;
  optional tmFidMsg index = 6;
  }
