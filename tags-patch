From 16c20a278d3b08f4f4288e30e14d8aea2f648710 Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Wed, 1 Jul 2015 16:10:30 +0100
Subject: [PATCH 01/12] Added MetaDataSet to target_set

---
 src/collectd.conf.pod  |  2 +
 src/daemon/meta_data.c | 99 ++++++++++++++++++++++++++++++++++++++++++++++++--
 src/daemon/meta_data.h |  1 +
 src/target_set.c       | 70 +++++++++++++++++++++++++++++++++--
 4 files changed, 165 insertions(+), 7 deletions(-)

diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index b2aab21..352115d 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -8676,6 +8676,8 @@ Available options:
 
 =item B<TypeInstance> I<String>
 
+=item B<MetaDataSet> I<String> I<String>
+
 Set the appropriate field to the given string. The strings for plugin instance
 and type instance may be empty, the strings for host and plugin may not be
 empty. It's currently not possible to set the type of a value this way.
diff --git a/src/daemon/meta_data.c b/src/daemon/meta_data.c
index 6ee8446..8ddd478 100644
--- a/src/daemon/meta_data.c
+++ b/src/daemon/meta_data.c
@@ -106,12 +106,15 @@ static meta_entry_t *md_entry_alloc (const char *key) /* {{{ */
   return (e);
 } /* }}} meta_entry_t *md_entry_alloc */
 
-static meta_entry_t *md_entry_clone (const meta_entry_t *orig) /* {{{ */
+/* XXX: The lock on md must be held while calling this function! */
+static meta_entry_t *md_entry_clone_contents (const meta_entry_t *orig) /* {{{ */
 {
   meta_entry_t *copy;
 
-  if (orig == NULL)
-    return (NULL);
+  /* WARNINGS :
+   *  - we do not check that orig != NULL here. You should have done it before.
+   *  - we do not set copy->next. DO NOT FORGET TO SET copy->next IN YOUR FUNCTION
+   */
 
   copy = md_entry_alloc (orig->key);
   copy->type = orig->type;
@@ -120,6 +123,18 @@ static meta_entry_t *md_entry_clone (const meta_entry_t *orig) /* {{{ */
   else
     copy->value = orig->value;
 
+  return (copy);
+} /* }}} meta_entry_t *md_entry_clone_contents */
+
+static meta_entry_t *md_entry_clone (const meta_entry_t *orig) /* {{{ */
+{
+  meta_entry_t *copy;
+
+  if (orig == NULL)
+    return (NULL);
+
+  copy = md_entry_clone_contents(orig);
+
   copy->next = md_entry_clone (orig->next);
   return (copy);
 } /* }}} meta_entry_t *md_entry_clone */
@@ -196,6 +211,63 @@ static int md_entry_insert (meta_data_t *md, meta_entry_t *e) /* {{{ */
 } /* }}} int md_entry_insert */
 
 /* XXX: The lock on md must be held while calling this function! */
+static int md_entry_insert_clone (meta_data_t *md, meta_entry_t *orig) /* {{{ */
+{
+  meta_entry_t *e;
+  meta_entry_t *this;
+  meta_entry_t *prev;
+
+  /* WARNINGS :
+   *  - we do not check that md and e != NULL here. You should have done it before.
+   *  - we do not use the lock. You should have set it before.
+   */
+
+  e = md_entry_clone_contents(orig);
+
+  prev = NULL;
+  this = md->head;
+  while (this != NULL)
+  {
+    if (strcasecmp (e->key, this->key) == 0)
+      break;
+
+    prev = this;
+    this = this->next;
+  }
+
+  if (this == NULL)
+  {
+    /* This key does not exist yet. */
+    if (md->head == NULL)
+      md->head = e;
+    else
+    {
+      assert (prev != NULL);
+      prev->next = e;
+    }
+
+    e->next = NULL;
+  }
+  else /* (this != NULL) */
+  {
+    if (prev == NULL)
+      md->head = e;
+    else
+      prev->next = e;
+
+    e->next = this->next;
+  }
+
+  if (this != NULL)
+  {
+    this->next = NULL;
+    md_entry_free (this);
+  }
+
+  return (0);
+} /* }}} int md_entry_insert_clone */
+
+/* XXX: The lock on md must be held while calling this function! */
 static meta_entry_t *md_entry_lookup (meta_data_t *md, /* {{{ */
     const char *key)
 {
@@ -250,6 +322,27 @@ meta_data_t *meta_data_clone (meta_data_t *orig) /* {{{ */
   return (copy);
 } /* }}} meta_data_t *meta_data_clone */
 
+int meta_data_clone_merge (meta_data_t **dest, meta_data_t *orig) /* {{{ */
+{
+  meta_entry_t *e;
+
+  if (orig == NULL)
+    return (0);
+
+  if(NULL == *dest) {
+    *dest = meta_data_clone(orig);
+    return(0);
+  }
+
+  pthread_mutex_lock (&orig->lock);
+  for(e=orig->head; NULL != e; e = e->next) {
+    md_entry_insert_clone((*dest), e);
+  }
+  pthread_mutex_unlock (&orig->lock);
+
+  return (0);
+} /* }}} int meta_data_clone_merge */
+
 void meta_data_destroy (meta_data_t *md) /* {{{ */
 {
   if (md == NULL)
diff --git a/src/daemon/meta_data.h b/src/daemon/meta_data.h
index fa48df3..9e448e5 100644
--- a/src/daemon/meta_data.h
+++ b/src/daemon/meta_data.h
@@ -43,6 +43,7 @@ typedef struct meta_data_s meta_data_t;
 
 meta_data_t *meta_data_create (void);
 meta_data_t *meta_data_clone (meta_data_t *orig);
+int meta_data_clone_merge (meta_data_t **dest, meta_data_t *orig);
 void meta_data_destroy (meta_data_t *md);
 
 int meta_data_exists (meta_data_t *md, const char *key);
diff --git a/src/target_set.c b/src/target_set.c
index daeaf8b..5e9d087 100644
--- a/src/target_set.c
+++ b/src/target_set.c
@@ -35,9 +35,27 @@ struct ts_data_s
   char *plugin_instance;
   /* char *type; */
   char *type_instance;
+  meta_data_t *meta;
 };
 typedef struct ts_data_s ts_data_t;
 
+int ts_util_get_key_and_string_wo_strdup (const oconfig_item_t *ci, char **ret_key, char **ret_string) /* {{{ */
+{
+  if ((ci->values_num != 2)
+      || (ci->values[0].type != OCONFIG_TYPE_STRING)
+      || (ci->values[1].type != OCONFIG_TYPE_STRING))
+  {
+    ERROR ("ts_util_get_key_and_string_wo_strdup: The %s option requires "
+        "exactly two string argument.", ci->key);
+    return (-1);
+  }
+
+  *ret_key = ci->values[0].value.string;
+  *ret_string = ci->values[1].value.string;
+
+  return (0);
+} /* }}} int ts_util_get_key_and_string_wo_strdup */
+
 static int ts_config_add_string (char **dest, /* {{{ */
     const oconfig_item_t *ci, int may_be_empty)
 {
@@ -60,6 +78,42 @@ static int ts_config_add_string (char **dest, /* {{{ */
   return (0);
 } /* }}} int ts_config_add_string */
 
+static int ts_config_add_meta (meta_data_t **dest, /* {{{ */
+    const oconfig_item_t *ci, int may_be_empty)
+{
+  char *key = NULL;
+  char *string = NULL;
+  int status;
+
+  status = ts_util_get_key_and_string_wo_strdup (ci, &key, &string);
+  if (status != 0)
+    return (status);
+
+  if (strlen (key) == 0)
+  {
+    ERROR ("Target `set': The `%s' option does not accept empty string as first argument.",
+        ci->key);
+    return (-1);
+  }
+
+  if (!may_be_empty && (strlen (string) == 0))
+  {
+    ERROR ("Target `set': The `%s' option does not accept empty string as second argument.",
+        ci->key);
+    return (-1);
+  }
+
+  if(NULL == (*dest)) {
+    // Create a new meta_data_t
+    if( NULL == (*dest = meta_data_create())) {
+      ERROR ("Target `set': failed to create a meta data for `%s'.", ci->key);
+      return (-1);
+    }
+  }
+
+  return(meta_data_add_string (*dest, key, string));
+} /* }}} int ts_config_add_meta */
+
 static int ts_destroy (void **user_data) /* {{{ */
 {
   ts_data_t *data;
@@ -76,6 +130,7 @@ static int ts_destroy (void **user_data) /* {{{ */
   free (data->plugin_instance);
   /* free (data->type); */
   free (data->type_instance);
+  meta_data_destroy(data->meta);
   free (data);
 
   return (0);
@@ -100,6 +155,7 @@ static int ts_create (const oconfig_item_t *ci, void **user_data) /* {{{ */
   data->plugin_instance = NULL;
   /* data->type = NULL; */
   data->type_instance = NULL;
+  data->meta = NULL;
 
   status = 0;
   for (i = 0; i < ci->children_num; i++)
@@ -121,8 +177,8 @@ static int ts_create (const oconfig_item_t *ci, void **user_data) /* {{{ */
       status = ts_config_add_string (&data->type, child,
           /* may be empty = */ 0);
 #endif
-    else if (strcasecmp ("TypeInstance", child->key) == 0)
-      status = ts_config_add_string (&data->type_instance, child,
+    else if (strcasecmp ("MetaDataSet", child->key) == 0)
+      status = ts_config_add_meta (&data->meta, child,
           /* may be empty = */ 1);
     else
     {
@@ -142,10 +198,12 @@ static int ts_create (const oconfig_item_t *ci, void **user_data) /* {{{ */
         && (data->plugin == NULL)
         && (data->plugin_instance == NULL)
         /* && (data->type == NULL) */
-        && (data->type_instance == NULL))
+        && (data->type_instance == NULL)
+        && (data->meta == NULL))
     {
       ERROR ("Target `set': You need to set at least one of `Host', "
-          "`Plugin', `PluginInstance' or `TypeInstance'.");
+          "`Plugin', `PluginInstance', `TypeInstance', "
+          "`MetaDataSet' or `MetaDataEval'.");
       status = -1;
     }
 
@@ -177,6 +235,10 @@ static int ts_invoke (const data_set_t *ds, value_list_t *vl, /* {{{ */
     return (-EINVAL);
   }
 
+  if(NULL != data->meta) {
+    meta_data_clone_merge(&(vl->meta), data->meta);
+  }
+
 #define SET_FIELD(f) if (data->f != NULL) { sstrncpy (vl->f, data->f, sizeof (vl->f)); }
   SET_FIELD (host);
   SET_FIELD (plugin);

From 9a97e6fa25e6703cbe1144cfb7f1c96a3056f8a2 Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Thu, 2 Jul 2015 16:32:50 +0100
Subject: [PATCH 02/12] write_tsdb uses meta data to reformat metrics and set
 tags

---
 src/collectd.conf.pod |  69 +++++++++++
 src/write_tsdb.c      | 316 +++++++++++++++++++++++++++++++++++++++++++-------
 2 files changed, 346 insertions(+), 39 deletions(-)

diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index 352115d..e4ab3ab 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -7198,6 +7198,75 @@ more than one DS.
 
 =back
 
+=head3 Note about rules and metadata
+
+The C<write_tsdb> plugin recognizes metadata :
+
+=over 4
+
+=item B<tsdb_prefix> B<Prefix>
+
+If set, metric name will be prefixed with B<Prefix>.
+
+Note : B<tsdb_prefix> also applies when you define B<tsdb_id>.
+
+=item B<tsdb_id> B<Id>
+
+When you define B<tsdb_id>, the metric name is not calculated but is B<Id> (with prefix if you defined B<tsdb_prefix>).
+
+=item B<tsdb_tag_plugin> B<tag_key>
+
+=item B<tsdb_tag_pluginInstance> B<tag_key>
+
+=item B<tsdb_tag_type> B<tag_key>
+
+=item B<tsdb_tag_typeInstance> B<tag_key>
+
+=item B<tsdb_tag_dsname> B<tag_key>
+
+If a B<tsdb_tag_*> is defined, the related item is removed from the metric name. If B<tag_key> is not empty,
+a tag will be added with key B<tag_key> and value the item.
+
+=back
+
+Example without B<tsdb_tag_*> :
+
+  cpu.1.cpu.user
+
+Same example with  :
+  tsdb_tag_pluginInstance = "cpu"
+  tsdb_tag_type = ""
+
+We get :
+  cpu.user cpu=1
+
+In this example, pluginInstance (named "1") is removed from the metric name and is set as a tag named "cpu".
+The type (named "cpu") is removed because B<tsdb_tag_type> is defined but is empty.
+
+You can define tags with filter rules and target_set :
+
+  <Chain "PreCache">
+    <Rule "opentsdb_cpu">
+      <Match "regex">
+        Plugin "^cpu$"
+      </Match>
+      <Target "set">
+        MetaDataSet "tsdb_tag_pluginInstance" "cpu"
+        MetaDataSet "tsdb_tag_type" ""
+      </Target>
+    </Rule>
+    <Rule "opentsdb_prefix">
+      <Match "regex">
+        Host "^"
+      </Match>
+      <Target "set">
+        MetaDataSet "tsdb_prefix" "sys."
+      </Target>
+    </Rule>
+  </Chain>
+
+This example will replace (for example) "cpu.1.cpu.user" with "sys.cpu.user cpu=1"
+
 =head2 Plugin C<write_mongodb>
 
 The I<write_mongodb plugin> will send values to I<MongoDB>, a schema-less
diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 2c39ec1..261fd6b 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -28,9 +28,11 @@
  * write_tsdb Authors:
  *   Brett Hawn <bhawn at llnw.com>
  *   Kevin Bowling <kbowling@llnw.com>
+ *   Yves Mettier <ymettier@free.fr>
  **/
 
 /* write_tsdb plugin configuation example
+ * --------------------------------------
  *
  * <Plugin write_tsdb>
  *   <Node>
@@ -39,6 +41,85 @@
  *     HostTags "status=production deviceclass=www"
  *   </Node>
  * </Plugin>
+ *
+ * write_tsdb meta_data
+ * --------------------
+ *  - tsdb_prefix : Will prefix the OpenTSDB <metric> (also prefix tsdb_id if defined)
+ *  - tsdb_id     : Replace the metric with this tag
+ *
+ *  - tsdb_tag_plugin         : When defined, tsdb_tag_* removes the related
+ *  - tsdb_tag_pluginInstance : item from metric id.
+ *  - tsdb_tag_type           : If it is not empty, it will be the key of an
+ *  - tsdb_tag_typeInstance   : opentsdb tag (the value is the item itself)
+ *  - tsdb_tag_dsname         : If it is empty, no tag is defined.
+ *
+ * write_tsdb plugin filter rules example
+ * --------------------------------------
+ *
+ * <Chain "PreCache">
+ *   <Rule "opentsdb_cpu">
+ *     <Match "regex">
+ *       Plugin "^cpu$"
+ *     </Match>
+ *     <Target "set">
+ *       MetaDataSet "tsdb_tag_pluginInstance" "cpu"
+ *       MetaDataSet "tsdb_tag_type" ""
+ *       MetaDataSet "tsdb_prefix" "sys."
+ *     </Target>
+ *   </Rule>
+ *   <Rule "opentsdb_df">
+ *     <Match "regex">
+ *       Plugin "^df$"
+ *     </Match>
+ *     <Target "set">
+ *       MetaDataSet "tsdb_tag_pluginInstance" "mount"
+ *       MetaDataSet "tsdb_tag_type" ""
+ *       MetaDataSet "tsdb_prefix" "sys."
+ *     </Target>
+ *   </Rule>
+ *   <Rule "opentsdb_disk">
+ *     <Match "regex">
+ *       Plugin "^disk$"
+ *     </Match>
+ *     <Target "set">
+ *       MetaDataSet "tsdb_tag_pluginInstance" "disk"
+ *       MetaDataSet "tsdb_prefix" "sys."
+ *     </Target>
+ *   </Rule>
+ *   <Rule "opentsdb_interface">
+ *     <Match "regex">
+ *       Plugin "^interface$"
+ *     </Match>
+ *     <Target "set">
+ *       MetaDataSet "tsdb_tag_pluginInstance" "iface"
+ *       MetaDataSet "tsdb_prefix" "sys."
+ *     </Target>
+ *   </Rule>
+ *   <Rule "opentsdb_load">
+ *     <Match "regex">
+ *       Plugin "^loac$"
+ *     </Match>
+ *     <Target "set">
+ *       MetaDataSet "tsdb_tag_type" ""
+ *       MetaDataSet "tsdb_prefix" "sys."
+ *     </Target>
+ *   </Rule>
+ *   <Rule "opentsdb_swap">
+ *     <Match "regex">
+ *       Plugin "^swap$"
+ *     </Match>
+ *     <Target "set">
+ *       MetaDataSet "tsdb_prefix" "sys."
+ *     </Target>
+ *   </Rule>
+ * </Chain>
+ *
+ * IMPORTANT WARNING
+ * -----------------
+ * OpenTSDB allows no more than 8 tags.
+ * Collectd admins should be aware of this when defining filter rules and host
+ * tags.
+ *
  */
 
 #include "collectd.h"
@@ -69,6 +150,20 @@
 # define WT_SEND_BUF_SIZE 1428
 #endif
 
+/* Meta data definitions about tsdb tags */
+#define TSDB_TAG_PLUGIN 0
+#define TSDB_TAG_PLUGININSTANCE 1
+#define TSDB_TAG_TYPE 2
+#define TSDB_TAG_TYPEINSTANCE 3
+#define TSDB_TAG_DSNAME 4
+static const char *meta_tag[] = {
+    "tsdb_tag_plugin",
+    "tsdb_tag_pluginInstance",
+    "tsdb_tag_type",
+    "tsdb_tag_typeInstance",
+    "tsdb_tag_dsname"
+};
+
 /*
  * Private variables
  */
@@ -341,15 +436,106 @@ static int wt_format_values(char *ret, size_t ret_len,
     return 0;
 }
 
+static int wt_format_tags(char *ret, int ret_len,
+                          const value_list_t *vl,
+                          const struct wt_callback *cb,
+                          const char *ds_name)
+{
+    int status;
+    char *temp = NULL;
+    char *ptr = ret;
+    size_t remaining_len = ret_len;
+
+#define TSDB_META_DATA_GET_STRING(tag) do { \
+        temp = NULL; \
+        status = meta_data_get_string(vl->meta, tag, &temp); \
+        if (status == -ENOENT) { \
+            temp = NULL; \
+            /* defaults to empty string */ \
+        } else if (status < 0) { \
+            sfree(temp); \
+            return status; \
+        } \
+    } while(0)
+
+#define TSDB_STRING_APPEND_SPRINTF(key, value) do { \
+        int n; \
+        const char *k = (key); \
+        if(k[0] != '\0') { \
+            n = ssnprintf(ptr, remaining_len, " %s=%s", k, value); \
+            if(n >= remaining_len) { \
+                ptr[0] = '\0'; \
+            } else { \
+                char *ptr2 = ptr+1; \
+                while(NULL != (ptr2 = strchr(ptr2, ' '))) ptr2[0] = '_';  \
+                ptr += n; \
+                remaining_len -= n; \
+            } \
+        } \
+    } while(0)
+
+    if (vl->meta) {
+        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_PLUGIN]);
+        if(temp) {
+            TSDB_STRING_APPEND_SPRINTF(temp, vl->plugin);
+            sfree(temp);
+        }
+
+        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_PLUGININSTANCE]);
+        if(temp) {
+            TSDB_STRING_APPEND_SPRINTF(temp, vl->plugin_instance);
+            sfree(temp);
+        }
+
+        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_TYPE]);
+        if(temp) {
+            TSDB_STRING_APPEND_SPRINTF(temp, vl->type);
+            sfree(temp);
+        }
+
+        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_TYPEINSTANCE]);
+        if(temp) {
+            TSDB_STRING_APPEND_SPRINTF(temp, vl->type_instance);
+            sfree(temp);
+        }
+
+        if(ds_name) {
+            TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_DSNAME]);
+            if(temp) {
+                TSDB_STRING_APPEND_SPRINTF(temp, ds_name);
+                sfree(temp);
+            }
+        }
+    } else {
+        ret[0] = '\0';
+    }
+
+#undef TSDB_META_DATA_GET_STRING
+#undef TSDB_STRING_APPEND_SPRINTF
+
+    return 0;
+}
+
 static int wt_format_name(char *ret, int ret_len,
                           const value_list_t *vl,
                           const struct wt_callback *cb,
                           const char *ds_name)
 {
     int status;
+    int i;
     char *temp = NULL;
-    char *prefix = "";
+    char *prefix = NULL;
     const char *meta_prefix = "tsdb_prefix";
+    char *tsdb_id = NULL;
+    const char *meta_id = "tsdb_id";
+
+    _Bool include_in_id[] = {
+        /* plugin =          */ 1,
+        /* plugin instance = */ (vl->plugin_instance[0] == '\0')?0:1,
+        /* type =            */ 1,
+        /* type instance =   */ (vl->type_instance[0] == '\0')?0:1,
+        /* ds_name =         */ (ds_name == NULL)?0:1
+    };
 
     if (vl->meta) {
         status = meta_data_get_string(vl->meta, meta_prefix, &temp);
@@ -361,54 +547,92 @@ static int wt_format_name(char *ret, int ret_len,
         } else {
             prefix = temp;
         }
-    }
 
-    if (ds_name != NULL) {
-        if (vl->plugin_instance[0] == '\0') {
-            if (vl->type_instance[0] == '\0') {
-                ssnprintf(ret, ret_len, "%s%s.%s.%s", prefix, vl->plugin,
-                        vl->type, ds_name);
-            } else {
-                ssnprintf(ret, ret_len, "%s%s.%s.%s.%s", prefix, vl->plugin,
-                        vl->type, vl->type_instance, ds_name);
-            }
-        } else { /* vl->plugin_instance != "" */
-            if (vl->type_instance[0] == '\0') {
-                ssnprintf(ret, ret_len, "%s%s.%s.%s.%s", prefix, vl->plugin,
-                        vl->plugin_instance, vl->type, ds_name);
-            } else {
-                ssnprintf(ret, ret_len, "%s%s.%s.%s.%s.%s", prefix,
-                        vl->plugin, vl->plugin_instance, vl->type,
-                        vl->type_instance, ds_name);
-            }
+        status = meta_data_get_string(vl->meta, meta_id, &temp);
+        if (status == -ENOENT) {
+            /* defaults to empty string */
+        } else if (status < 0) {
+            sfree(temp);
+            return status;
+        } else {
+            tsdb_id = temp;
         }
-    } else { /* ds_name == NULL */
-        if (vl->plugin_instance[0] == '\0') {
-            if (vl->type_instance[0] == '\0') {
-                ssnprintf(ret, ret_len, "%s%s.%s", prefix, vl->plugin,
-                        vl->type);
-            } else {
-                ssnprintf(ret, ret_len, "%s%s.%s.%s", prefix, vl->plugin,
-                        vl->type_instance, vl->type);
-            }
-        } else { /* vl->plugin_instance != "" */
-            if (vl->type_instance[0] == '\0') {
-                ssnprintf(ret, ret_len, "%s%s.%s.%s", prefix, vl->plugin,
-                        vl->plugin_instance, vl->type);
+
+        for(i=0; i < (sizeof(meta_tag)/sizeof(*meta_tag)); i++) {
+            if(0 == meta_data_exists(vl->meta, meta_tag[i])) {
+                /* defaults to already initialized format */
             } else {
-                ssnprintf(ret, ret_len, "%s%s.%s.%s.%s", prefix, vl->plugin,
-                        vl->plugin_instance, vl->type, vl->type_instance);
+                include_in_id[i] = 0;
             }
         }
     }
+    if(tsdb_id) {
+        ssnprintf(ret, ret_len, "%s%s", prefix?prefix:"", tsdb_id);
+    } else {
+#define TSDB_STRING_APPEND_STRING(string) do { \
+    const char *str = (string); \
+    size_t len = strlen(str); \
+    if(len > (remaining_len - 1)) { \
+        ptr[0] = '\0'; \
+        return(-ENOSPC); \
+    } \
+    if(len > 0) {  \
+        memcpy(ptr, str, len); \
+        ptr += len; \
+        remaining_len -= len; \
+    } \
+} while(0)
+
+#define TSDB_STRING_APPEND_DOT do { \
+    if(remaining_len > 2) {  \
+        ptr[0] = '.'; \
+        ptr ++; \
+        remaining_len --; \
+    } else {\
+        ptr[0] = '\0'; \
+        return(-ENOSPC); \
+    } \
+} while(0)
+
+        char *ptr = ret;
+        size_t remaining_len = ret_len;
+        if(prefix) {
+            TSDB_STRING_APPEND_STRING(prefix);
+        }
+        if(include_in_id[TSDB_TAG_PLUGIN]) {
+            TSDB_STRING_APPEND_STRING(vl->plugin);
+        }
 
-    sfree(temp);
+        if(include_in_id[TSDB_TAG_PLUGININSTANCE]) {
+            TSDB_STRING_APPEND_DOT;
+            TSDB_STRING_APPEND_STRING(vl->plugin_instance);
+        }
+        if(include_in_id[TSDB_TAG_TYPE]) {
+            TSDB_STRING_APPEND_DOT;
+            TSDB_STRING_APPEND_STRING(vl->type);
+        }
+        if(include_in_id[TSDB_TAG_TYPEINSTANCE]) {
+            TSDB_STRING_APPEND_DOT;
+            TSDB_STRING_APPEND_STRING(vl->type_instance);
+        }
+        if(include_in_id[TSDB_TAG_DSNAME]) {
+            TSDB_STRING_APPEND_DOT;
+            TSDB_STRING_APPEND_STRING(ds_name);
+        }
+        ptr[0] = '\0';
+#undef TSDB_STRING_APPEND_STRING
+#undef TSDB_STRING_APPEND_DOT
+    }
+
+    sfree(tsdb_id);
+    sfree(prefix);
     return 0;
 }
 
 static int wt_send_message (const char* key, const char* value,
+                            const char* value_tags,
                             cdtime_t time, struct wt_callback *cb,
-                            const char* host, meta_data_t *md)
+                            const value_list_t *vl)
 {
     int status;
     size_t message_len;
@@ -417,6 +641,8 @@ static int wt_send_message (const char* key, const char* value,
     char message[1024];
     char *host_tags = cb->host_tags ? cb->host_tags : "";
     const char *meta_tsdb = "tsdb_tags";
+    const char* host = vl->host;
+    meta_data_t *md = vl->meta;
 
     /* skip if value is NaN */
     if (value[0] == 'n')
@@ -438,11 +664,12 @@ static int wt_send_message (const char* key, const char* value,
 
     status = ssnprintf (message,
                              sizeof(message),
-                             "put %s %.0f %s fqdn=%s %s %s\r\n",
+                             "put %s %.0f %s fqdn=%s %s %s %s\r\n",
                              key,
                              CDTIME_T_TO_DOUBLE(time),
                              value,
                              host,
+                             value_tags,
                              tags,
                              host_tags);
     sfree(temp);
@@ -507,6 +734,7 @@ static int wt_write_messages(const data_set_t *ds, const value_list_t *vl,
 {
     char key[10*DATA_MAX_NAME_LEN];
     char values[512];
+    char tags[10*DATA_MAX_NAME_LEN];
 
     int status;
     size_t i;
@@ -545,8 +773,18 @@ static int wt_write_messages(const data_set_t *ds, const value_list_t *vl,
             return status;
         }
 
+        /* Copy tags from p-pi/t-ti ds notation into tags */
+        tags[0] = '\0';
+        status = wt_format_tags(tags, sizeof(tags), vl, cb, ds_name);
+        if (status != 0)
+        {
+            ERROR("write_tsdb plugin: error with format_tags");
+            return status;
+        }
+        
+
         /* Send the message to tsdb */
-        status = wt_send_message(key, values, vl->time, cb, vl->host, vl->meta);
+        status = wt_send_message(key, values, tags, vl->time, cb, vl);
         if (status != 0)
         {
             ERROR("write_tsdb plugin: error with "

From 32ce87f078ff48faac9b2bb685987b579ac1130e Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Tue, 7 Jul 2015 14:10:28 +0100
Subject: [PATCH 03/12] write_tsdb new meta_tag : tsdb_tag for any tagk=tagv

---
 src/collectd.conf.pod |  5 +++++
 src/write_tsdb.c      | 42 ++++++++++++++++++++++++++++++++++--------
 2 files changed, 39 insertions(+), 8 deletions(-)

diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index e4ab3ab..12f510f 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -7227,6 +7227,11 @@ When you define B<tsdb_id>, the metric name is not calculated but is B<Id> (with
 If a B<tsdb_tag_*> is defined, the related item is removed from the metric name. If B<tag_key> is not empty,
 a tag will be added with key B<tag_key> and value the item.
 
+=item B<tsdb_tag> B<tag_key>=B<tag_value>
+
+When you define a B<tsdb_tag> B<tag_key>=B<tag_value> key-value pair, a tag is added (copy/pasted from
+the defined B<tag_key>=B<tag_value>)
+
 =back
 
 Example without B<tsdb_tag_*> :
diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 261fd6b..900b555 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -53,6 +53,8 @@
  *  - tsdb_tag_typeInstance   : opentsdb tag (the value is the item itself)
  *  - tsdb_tag_dsname         : If it is empty, no tag is defined.
  *
+ *  - tsdb_tag                : Should contain "tagk=tagv". Il will add a tag.
+ *
  * write_tsdb plugin filter rules example
  * --------------------------------------
  *
@@ -156,7 +158,7 @@
 #define TSDB_TAG_TYPE 2
 #define TSDB_TAG_TYPEINSTANCE 3
 #define TSDB_TAG_DSNAME 4
-static const char *meta_tag[] = {
+static const char *meta_tag_metric_id[] = {
     "tsdb_tag_plugin",
     "tsdb_tag_pluginInstance",
     "tsdb_tag_type",
@@ -445,6 +447,7 @@ static int wt_format_tags(char *ret, int ret_len,
     char *temp = NULL;
     char *ptr = ret;
     size_t remaining_len = ret_len;
+    const char *meta_tag = "tsdb_tag";
 
 #define TSDB_META_DATA_GET_STRING(tag) do { \
         temp = NULL; \
@@ -475,37 +478,60 @@ static int wt_format_tags(char *ret, int ret_len,
     } while(0)
 
     if (vl->meta) {
-        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_PLUGIN]);
+        TSDB_META_DATA_GET_STRING(meta_tag_metric_id[TSDB_TAG_PLUGIN]);
         if(temp) {
             TSDB_STRING_APPEND_SPRINTF(temp, vl->plugin);
             sfree(temp);
         }
 
-        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_PLUGININSTANCE]);
+        TSDB_META_DATA_GET_STRING(meta_tag_metric_id[TSDB_TAG_PLUGININSTANCE]);
         if(temp) {
             TSDB_STRING_APPEND_SPRINTF(temp, vl->plugin_instance);
             sfree(temp);
         }
 
-        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_TYPE]);
+        TSDB_META_DATA_GET_STRING(meta_tag_metric_id[TSDB_TAG_TYPE]);
         if(temp) {
             TSDB_STRING_APPEND_SPRINTF(temp, vl->type);
             sfree(temp);
         }
 
-        TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_TYPEINSTANCE]);
+        TSDB_META_DATA_GET_STRING(meta_tag_metric_id[TSDB_TAG_TYPEINSTANCE]);
         if(temp) {
             TSDB_STRING_APPEND_SPRINTF(temp, vl->type_instance);
             sfree(temp);
         }
 
         if(ds_name) {
-            TSDB_META_DATA_GET_STRING(meta_tag[TSDB_TAG_DSNAME]);
+            TSDB_META_DATA_GET_STRING(meta_tag_metric_id[TSDB_TAG_DSNAME]);
             if(temp) {
                 TSDB_STRING_APPEND_SPRINTF(temp, ds_name);
                 sfree(temp);
             }
         }
+
+        TSDB_META_DATA_GET_STRING(meta_tag);
+        if(temp) {
+            int n;
+            if(NULL == strchr(temp, '=')) {
+                ERROR("write_tsdb plugin: meta_data tag '%s' does not contain a '=' char (host=%s, plugin=%s, type=%s)",
+                        temp, vl->host, vl->plugin, vl->type);
+                sfree(temp);
+            }
+            if(temp[0] != '\0') {
+                n = ssnprintf(ptr, remaining_len, " %s", temp);
+                if(n >= remaining_len) {
+                    ptr[0] = '\0';
+                } else {
+                    char *ptr2 = ptr+1;
+                    while(NULL != (ptr2 = strchr(ptr2, ' '))) ptr2[0] = '_'; 
+                    ptr += n;
+                    remaining_len -= n;
+                }
+            }
+            sfree(temp);
+        }
+
     } else {
         ret[0] = '\0';
     }
@@ -558,8 +584,8 @@ static int wt_format_name(char *ret, int ret_len,
             tsdb_id = temp;
         }
 
-        for(i=0; i < (sizeof(meta_tag)/sizeof(*meta_tag)); i++) {
-            if(0 == meta_data_exists(vl->meta, meta_tag[i])) {
+        for(i=0; i < (sizeof(meta_tag_metric_id)/sizeof(*meta_tag_metric_id)); i++) {
+            if(0 == meta_data_exists(vl->meta, meta_tag_metric_id[i])) {
                 /* defaults to already initialized format */
             } else {
                 include_in_id[i] = 0;

From 87e08a207aef83f2e3329df0479f959df8ef8445 Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Sat, 1 Aug 2015 01:39:52 +0200
Subject: [PATCH 04/12] tsdb bugfix : ignore tags with empty value

---
 src/write_tsdb.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 900b555..01d6cde 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -464,8 +464,9 @@ static int wt_format_tags(char *ret, int ret_len,
 #define TSDB_STRING_APPEND_SPRINTF(key, value) do { \
         int n; \
         const char *k = (key); \
-        if(k[0] != '\0') { \
-            n = ssnprintf(ptr, remaining_len, " %s=%s", k, value); \
+        const char *v = (value); \
+        if(k[0] != '\0' && v[0] != '\0') { \
+            n = ssnprintf(ptr, remaining_len, " %s=%s", k, v); \
             if(n >= remaining_len) { \
                 ptr[0] = '\0'; \
             } else { \

From 3d97d393cb2c2f4160ccf9f7b2ae7922d1998756 Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Thu, 20 Aug 2015 15:15:09 +0100
Subject: [PATCH 05/12] bugfix and allow meta_tags as key1=val1 key2=val2

---
 src/collectd.conf.pod |  5 ++++-
 src/write_tsdb.c      | 43 +++++++++++++++++++++++++++++++++++--------
 2 files changed, 39 insertions(+), 9 deletions(-)

diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index 12f510f..1f86412 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -7230,7 +7230,10 @@ a tag will be added with key B<tag_key> and value the item.
 =item B<tsdb_tag> B<tag_key>=B<tag_value>
 
 When you define a B<tsdb_tag> B<tag_key>=B<tag_value> key-value pair, a tag is added (copy/pasted from
-the defined B<tag_key>=B<tag_value>)
+the defined B<tag_key>=B<tag_value>). If you want to add more than one tag, put them on the same line and
+separe them with spaces. Example :
+
+  MetaDataSet "tsdb_tag" "k1=v1 k2=v2 k3=v3"
 
 =back
 
diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 01d6cde..4d17dd6 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -54,6 +54,8 @@
  *  - tsdb_tag_dsname         : If it is empty, no tag is defined.
  *
  *  - tsdb_tag                : Should contain "tagk=tagv". Il will add a tag.
+ *                            : "tagk1=tagv1 tagk2=tagv2..." is allowed.
+ *                            : It will be sent as is to the TSDB server.
  *
  * write_tsdb plugin filter rules example
  * --------------------------------------
@@ -514,23 +516,48 @@ static int wt_format_tags(char *ret, int ret_len,
         TSDB_META_DATA_GET_STRING(meta_tag);
         if(temp) {
             int n;
-            if(NULL == strchr(temp, '=')) {
-                ERROR("write_tsdb plugin: meta_data tag '%s' does not contain a '=' char (host=%s, plugin=%s, type=%s)",
-                        temp, vl->host, vl->plugin, vl->type);
-                sfree(temp);
+            char *key = temp;
+            while(NULL != temp) {
+                char *ptr1 = strchr(key, '=');
+                char *ptr2 = strchr(key, ' ');
+                if(NULL == ptr1) {
+                    ERROR("write_tsdb plugin: meta_data tag '%s' is missing a '=' char (host=%s, plugin=%s, type=%s)",
+                            temp, vl->host, vl->plugin, vl->type);
+                    sfree(temp);
+                    break;
+                }
+                if(NULL == ptr2) break; /* OK, no space. Good. */
+                
+                if(ptr2 < ptr1) {
+                    ERROR("write_tsdb plugin: meta_data tag '%s' contains space in key definition (host=%s, plugin=%s, type=%s)",
+                            temp, vl->host, vl->plugin, vl->type);
+                    sfree(temp);
+                    break;
+                }
+
+                key = ptr2;
+                while(' ' == ptr2[0]) ptr2++;
+                if('\0' == ptr2[0]) {
+                    /* temp ends with spaces */
+                    key[0] = '\0';
+                    break;
+                }
+                key = ptr2;
             }
-            if(temp[0] != '\0') {
+                
+            if(temp && temp[0] != '\0') {
                 n = ssnprintf(ptr, remaining_len, " %s", temp);
                 if(n >= remaining_len) {
                     ptr[0] = '\0';
                 } else {
-                    char *ptr2 = ptr+1;
-                    while(NULL != (ptr2 = strchr(ptr2, ' '))) ptr2[0] = '_'; 
+                    /* We do not check the tags syntax here. It should have
+                     * been done earlier.
+                     */
                     ptr += n;
                     remaining_len -= n;
                 }
             }
-            sfree(temp);
+            if(temp) sfree(temp);
         }
 
     } else {

From 1d584ae6b8c7417de9bebcb0240b0d33ddf4a5a9 Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Fri, 18 Sep 2015 14:55:20 +0100
Subject: [PATCH 06/12] Replaced tsdb_tag with tsdb_tag_add_*

---
 src/collectd.conf.pod | 12 ++++++----
 src/write_tsdb.c      | 63 ++++++++++++++++++++++-----------------------------
 2 files changed, 34 insertions(+), 41 deletions(-)

diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index 1f86412..3e7f40f 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -7227,13 +7227,15 @@ When you define B<tsdb_id>, the metric name is not calculated but is B<Id> (with
 If a B<tsdb_tag_*> is defined, the related item is removed from the metric name. If B<tag_key> is not empty,
 a tag will be added with key B<tag_key> and value the item.
 
-=item B<tsdb_tag> B<tag_key>=B<tag_value>
+=item B<tsdb_tag_add_XX> B<tag_value>
 
-When you define a B<tsdb_tag> B<tag_key>=B<tag_value> key-value pair, a tag is added (copy/pasted from
-the defined B<tag_key>=B<tag_value>). If you want to add more than one tag, put them on the same line and
-separe them with spaces. Example :
+When you define a B<tsdb_tag_add_XX>, a B<tag_key>=B<tag_value> key-value pair tag is added. The
+key comes from B<tsdb_tag_add_XX> and would be B<XX> here. Note that you cannot define the same tag twice.
+Examples: 
 
-  MetaDataSet "tsdb_tag" "k1=v1 k2=v2 k3=v3"
+  MetaDataSet "tsdb_tag_add_k1" "v1"
+  MetaDataSet "tsdb_tag_add_k2" "v2"
+  MetaDataSet "tsdb_tag_add_k3" "v3"
 
 =back
 
diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 4d17dd6..507adf5 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -53,8 +53,10 @@
  *  - tsdb_tag_typeInstance   : opentsdb tag (the value is the item itself)
  *  - tsdb_tag_dsname         : If it is empty, no tag is defined.
  *
- *  - tsdb_tag                : Should contain "tagk=tagv". Il will add a tag.
- *                            : "tagk1=tagv1 tagk2=tagv2..." is allowed.
+ *  - tsdb_tag_add_*          : Should contain "tagv". Il will add a tag.
+ *                            : The key tagk comes from the tsdb_tag_add_*
+ *                            : tag. Example : tsdb_tag_add_status adds a tag
+ *                            : named 'status'.
  *                            : It will be sent as is to the TSDB server.
  *
  * write_tsdb plugin filter rules example
@@ -449,7 +451,9 @@ static int wt_format_tags(char *ret, int ret_len,
     char *temp = NULL;
     char *ptr = ret;
     size_t remaining_len = ret_len;
-    const char *meta_tag = "tsdb_tag";
+    char **meta_toc;
+    int i,n;
+#define TSDB_META_TAG_ADD_PREFIX "tsdb_tag_add_"
 
 #define TSDB_META_DATA_GET_STRING(tag) do { \
         temp = NULL; \
@@ -513,40 +517,25 @@ static int wt_format_tags(char *ret, int ret_len,
             }
         }
 
-        TSDB_META_DATA_GET_STRING(meta_tag);
-        if(temp) {
-            int n;
-            char *key = temp;
-            while(NULL != temp) {
-                char *ptr1 = strchr(key, '=');
-                char *ptr2 = strchr(key, ' ');
-                if(NULL == ptr1) {
-                    ERROR("write_tsdb plugin: meta_data tag '%s' is missing a '=' char (host=%s, plugin=%s, type=%s)",
-                            temp, vl->host, vl->plugin, vl->type);
-                    sfree(temp);
-                    break;
-                }
-                if(NULL == ptr2) break; /* OK, no space. Good. */
-                
-                if(ptr2 < ptr1) {
-                    ERROR("write_tsdb plugin: meta_data tag '%s' contains space in key definition (host=%s, plugin=%s, type=%s)",
-                            temp, vl->host, vl->plugin, vl->type);
-                    sfree(temp);
-                    break;
-                }
-
-                key = ptr2;
-                while(' ' == ptr2[0]) ptr2++;
-                if('\0' == ptr2[0]) {
-                    /* temp ends with spaces */
-                    key[0] = '\0';
-                    break;
-                }
-                key = ptr2;
+        n = meta_data_toc(vl->meta, &meta_toc);
+        for(i=0; i<n; i++) {
+            if(strncmp(meta_toc[i], TSDB_META_TAG_ADD_PREFIX, sizeof(TSDB_META_TAG_ADD_PREFIX)-1)) {
+                free(meta_toc[i]);
+                continue;
+            }
+            if( '\0' == meta_toc[i][sizeof(TSDB_META_TAG_ADD_PREFIX)-1]) {
+                ERROR("write_tsdb plugin: meta_data tag '%s' is unknown (host=%s, plugin=%s, type=%s)",
+                        temp, vl->host, vl->plugin, vl->type);
+                free(meta_toc[i]);
+                continue;
             }
-                
-            if(temp && temp[0] != '\0') {
-                n = ssnprintf(ptr, remaining_len, " %s", temp);
+
+            TSDB_META_DATA_GET_STRING(meta_toc[i]);
+            if(temp && temp[0]) {
+                int n;
+                char *key = meta_toc[i]+sizeof(TSDB_META_TAG_ADD_PREFIX)-1;
+
+                n = ssnprintf(ptr, remaining_len, " %s=%s", key, temp);
                 if(n >= remaining_len) {
                     ptr[0] = '\0';
                 } else {
@@ -558,7 +547,9 @@ static int wt_format_tags(char *ret, int ret_len,
                 }
             }
             if(temp) sfree(temp);
+            free(meta_toc[i]);
         }
+        if(meta_toc) free(meta_toc);
 
     } else {
         ret[0] = '\0';

From b9a37bfb500640d620d18baa10b98f3aad4d9ecf Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Fri, 18 Sep 2015 14:59:05 +0100
Subject: [PATCH 07/12] Bugfix : don't close(-1)

---
 src/write_tsdb.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 507adf5..552294e 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -313,7 +313,6 @@ static int wt_callback_init(struct wt_callback *cb)
         ERROR("write_tsdb plugin: Connecting to %s:%s failed. "
               "The last error was: %s", node, service,
               sstrerror (errno, errbuf, sizeof(errbuf)));
-        close(cb->sock_fd);
         return -1;
     }
 

From b5b568e1ad23b39f12e1b504f8a8488eb6563ad7 Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Sun, 27 Sep 2015 17:30:19 +0100
Subject: [PATCH 08/12] Improved logging (one message only after deconnection)

---
 src/write_tsdb.c | 64 ++++++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 48 insertions(+), 16 deletions(-)

diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 552294e..94abdad 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -190,6 +190,8 @@ struct wt_callback
     cdtime_t send_buf_init_time;
 
     pthread_mutex_t send_lock;
+
+    _Bool    connect_failed_log_enabled;
 };
 
 
@@ -281,8 +283,11 @@ static int wt_callback_init(struct wt_callback *cb)
     status = getaddrinfo(node, service, &ai_hints, &ai_list);
     if (status != 0)
     {
-        ERROR("write_tsdb plugin: getaddrinfo (%s, %s) failed: %s",
-              node, service, gai_strerror (status));
+        if(cb->connect_failed_log_enabled) {
+            ERROR("write_tsdb plugin: getaddrinfo (%s, %s) failed: %s",
+                    node, service, gai_strerror (status));
+            cb->connect_failed_log_enabled = 0;
+        }
         return -1;
     }
 
@@ -309,13 +314,20 @@ static int wt_callback_init(struct wt_callback *cb)
 
     if (cb->sock_fd < 0)
     {
-        char errbuf[1024];
-        ERROR("write_tsdb plugin: Connecting to %s:%s failed. "
-              "The last error was: %s", node, service,
-              sstrerror (errno, errbuf, sizeof(errbuf)));
+        if(cb->connect_failed_log_enabled) {
+            char errbuf[1024];
+            ERROR("write_tsdb plugin: Connecting to %s:%s failed. "
+                    "The last error was: %s", node, service,
+                    sstrerror (errno, errbuf, sizeof(errbuf)));
+            cb->connect_failed_log_enabled = 0;
+        }
         return -1;
     }
 
+    if(0 == cb->connect_failed_log_enabled) {
+        WARNING("write_tsdb plugin: Connecting to %s:%s succeeded.",node, service);
+        cb->connect_failed_log_enabled = 1;
+    }
     wt_reset_buffer(cb);
 
     return 0;
@@ -365,7 +377,11 @@ static int wt_flush(cdtime_t timeout,
         status = wt_callback_init(cb);
         if (status != 0)
         {
-            ERROR("write_tsdb plugin: wt_callback_init failed.");
+            if(cb->connect_failed_log_enabled || cb->sock_fd >= 0) {
+                /* Do not log if socket is not enabled : it was logged already
+                 * in wt_callback_init(). */
+                ERROR("write_tsdb plugin: wt_callback_init failed.");
+            }
             pthread_mutex_unlock(&cb->send_lock);
             return -1;
         }
@@ -688,6 +704,9 @@ static int wt_send_message (const char* key, const char* value,
     const char* host = vl->host;
     meta_data_t *md = vl->meta;
 
+    const char *node = cb->node ? cb->node : WT_DEFAULT_NODE;
+    const char *service = cb->service ? cb->service : WT_DEFAULT_SERVICE;
+
     /* skip if value is NaN */
     if (value[0] == 'n')
         return 0;
@@ -697,9 +716,8 @@ static int wt_send_message (const char* key, const char* value,
         if (status == -ENOENT) {
             /* defaults to empty string */
         } else if (status < 0) {
-            ERROR("write_tsdb plugin: tags metadata get failure");
+            ERROR("write_tsdb plugin (%s:%s): tags metadata get failure", node, service);
             sfree(temp);
-            pthread_mutex_unlock(&cb->send_lock);
             return status;
         } else {
             tags = temp;
@@ -722,8 +740,8 @@ static int wt_send_message (const char* key, const char* value,
     message_len = (size_t) status;
 
     if (message_len >= sizeof(message)) {
-        ERROR("write_tsdb plugin: message buffer too small: "
-              "Need %zu bytes.", message_len + 1);
+        ERROR("write_tsdb plugin(%s:%s): message buffer too small: "
+              "Need %zu bytes.", node, service, message_len + 1);
         return -1;
     }
 
@@ -734,7 +752,12 @@ static int wt_send_message (const char* key, const char* value,
         status = wt_callback_init(cb);
         if (status != 0)
         {
-            ERROR("write_tsdb plugin: wt_callback_init failed.");
+            if(cb->connect_failed_log_enabled || cb->sock_fd >= 0) {
+                /* Do not log if socket is not enabled : it was logged already
+                 * in wt_callback_init(). */
+                ERROR("write_tsdb plugin (%s:%s): wt_callback_init failed.", node, service);
+                cb->connect_failed_log_enabled = 0;
+            }
             pthread_mutex_unlock(&cb->send_lock);
             return -1;
         }
@@ -761,8 +784,8 @@ static int wt_send_message (const char* key, const char* value,
     cb->send_buf_free -= message_len;
 
     DEBUG("write_tsdb plugin: [%s]:%s buf %zu/%zu (%.1f %%) \"%s\"",
-          cb->node,
-          cb->service,
+          node,
+          service,
           cb->send_buf_fill, sizeof(cb->send_buf),
           100.0 * ((double) cb->send_buf_fill) /
           ((double) sizeof(cb->send_buf)),
@@ -783,6 +806,10 @@ static int wt_write_messages(const data_set_t *ds, const value_list_t *vl,
     int status;
     size_t i;
 
+    const char *node = cb->node ? cb->node : WT_DEFAULT_NODE;
+    const char *service = cb->service ? cb->service : WT_DEFAULT_SERVICE;
+
+
     if (0 != strcmp(ds->type, vl->type))
     {
         ERROR("write_tsdb plugin: DS type does not match "
@@ -831,8 +858,12 @@ static int wt_write_messages(const data_set_t *ds, const value_list_t *vl,
         status = wt_send_message(key, values, tags, vl->time, cb, vl);
         if (status != 0)
         {
-            ERROR("write_tsdb plugin: error with "
-                  "wt_send_message");
+            if(cb->connect_failed_log_enabled) {
+                /* Do not log if socket is not enabled : it was logged already
+                 * in wt_callback_init(). */
+                ERROR("write_tsdb plugin (%s:%s): error with "
+                        "wt_send_message", node, service);
+            }
             return status;
         }
     }
@@ -875,6 +906,7 @@ static int wt_config_tsd(oconfig_item_t *ci)
     cb->service = NULL;
     cb->host_tags = NULL;
     cb->store_rates = 0;
+    cb->connect_failed_log_enabled = 1;
 
     pthread_mutex_init (&cb->send_lock, NULL);
 

From a58cc3e51743cd92f6d8a0bb37a88394b588da8e Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Wed, 14 Oct 2015 15:32:56 +0100
Subject: [PATCH 09/12] Prevent DNS flood when TSDB is not available

---
 src/collectd.conf.pod | 18 +++++++++++++-
 src/write_tsdb.c      | 68 +++++++++++++++++++++++++++++++++++++--------------
 2 files changed, 66 insertions(+), 20 deletions(-)

diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index 3e7f40f..c314c27 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -7157,6 +7157,7 @@ packets.
 Synopsis:
 
  <Plugin write_tsdb>
+   DNS_Cache_TTL 60
    <Node "example">
      Host "tsd-1.my.domain"
      Port "4242"
@@ -7165,7 +7166,22 @@ Synopsis:
  </Plugin>
 
 The configuration consists of one or more E<lt>B<Node>E<nbsp>I<Name>E<gt>
-blocks. Inside the B<Node> blocks, the following options are recognized:
+blocks and global directives.
+
+Global directives are:
+
+=over 4
+
+=item B<DNS_Cache_TTL> I<ttl>
+
+When Collectd connects to a TSDB node, it will request the DNS. This can become
+a problem is the TSDN node is unavailable or badly configured because Collected
+will request DNS in order to reconnect for every metric, which can flood your DNS.
+So you can cache the last value for C<ttl> seconds (default: 60s).
+
+=back
+
+Inside the B<Node> blocks, the following options are recognized:
 
 =over 4
 
diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 94abdad..11df3fd 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -175,6 +175,8 @@ static const char *meta_tag_metric_id[] = {
  */
 struct wt_callback
 {
+    struct addrinfo * sock_info;
+    cdtime_t sock_info_last_update;
     int      sock_fd;
 
     char     *node;
@@ -194,6 +196,8 @@ struct wt_callback
     _Bool    connect_failed_log_enabled;
 };
 
+static cdtime_t dnsttl = TIME_T_TO_CDTIME_T(60);
+
 
 /*
  * Functions
@@ -260,10 +264,9 @@ static int wt_flush_nolock(cdtime_t timeout, struct wt_callback *cb)
 
 static int wt_callback_init(struct wt_callback *cb)
 {
-    struct addrinfo ai_hints;
-    struct addrinfo *ai_list;
     struct addrinfo *ai_ptr;
     int status;
+    cdtime_t now;
 
     const char *node = cb->node ? cb->node : WT_DEFAULT_NODE;
     const char *service = cb->service ? cb->service : WT_DEFAULT_SERVICE;
@@ -271,28 +274,49 @@ static int wt_callback_init(struct wt_callback *cb)
     if (cb->sock_fd > 0)
         return 0;
 
-    memset(&ai_hints, 0, sizeof(ai_hints));
+    now = cdtime();
+    if ((cb->sock_info_last_update + dnsttl) < now) {
+        if(cb->sock_info) {
+            freeaddrinfo(cb->sock_info);
+            cb->sock_info = NULL;
+        }
+    }
+
+    if(NULL == cb->sock_info) {
+        struct addrinfo ai_hints;
+
+        memset(&ai_hints, 0, sizeof(ai_hints));
 #ifdef AI_ADDRCONFIG
-    ai_hints.ai_flags    |= AI_ADDRCONFIG;
+        ai_hints.ai_flags    |= AI_ADDRCONFIG;
 #endif
-    ai_hints.ai_family   = AF_UNSPEC;
-    ai_hints.ai_socktype = SOCK_STREAM;
+        ai_hints.ai_family   = AF_UNSPEC;
+        ai_hints.ai_socktype = SOCK_STREAM;
 
-    ai_list = NULL;
+        if ((cb->sock_info_last_update + dnsttl) >= now) {
+                DEBUG("write_tsdb plugin: too many getaddrinfo (%s, %s) failures",
+                        node, service);
+            return(-1);
+        }
 
-    status = getaddrinfo(node, service, &ai_hints, &ai_list);
-    if (status != 0)
-    {
-        if(cb->connect_failed_log_enabled) {
-            ERROR("write_tsdb plugin: getaddrinfo (%s, %s) failed: %s",
-                    node, service, gai_strerror (status));
-            cb->connect_failed_log_enabled = 0;
+        cb->sock_info_last_update = now;
+        status = getaddrinfo(node, service, &ai_hints, &(cb->sock_info));
+        if (status != 0)
+        {
+            if(cb->sock_info) {
+                freeaddrinfo(cb->sock_info);
+                cb->sock_info = NULL;
+            }
+            if(cb->connect_failed_log_enabled) {
+                ERROR("write_tsdb plugin: getaddrinfo (%s, %s) failed: %s",
+                        node, service, gai_strerror (status));
+                cb->connect_failed_log_enabled = 0;
+            }
+            return -1;
         }
-        return -1;
     }
 
-    assert (ai_list != NULL);
-    for (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)
+    assert (cb->sock_info != NULL);
+    for (ai_ptr = cb->sock_info; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)
     {
         cb->sock_fd = socket(ai_ptr->ai_family, ai_ptr->ai_socktype,
                              ai_ptr->ai_protocol);
@@ -310,8 +334,6 @@ static int wt_callback_init(struct wt_callback *cb)
         break;
     }
 
-    freeaddrinfo(ai_list);
-
     if (cb->sock_fd < 0)
     {
         if(cb->connect_failed_log_enabled) {
@@ -901,6 +923,8 @@ static int wt_config_tsd(oconfig_item_t *ci)
         return -1;
     }
     memset(cb, 0, sizeof(*cb));
+    cb->sock_info = NULL;
+    cb->sock_info_last_update = 0;
     cb->sock_fd = -1;
     cb->node = NULL;
     cb->service = NULL;
@@ -956,6 +980,12 @@ static int wt_config(oconfig_item_t *ci)
 
         if (strcasecmp("Node", child->key) == 0)
             wt_config_tsd(child);
+        if (strcasecmp("DNS_Cache_TTL", child->key) == 0)
+        {
+            int ttl;
+            cf_util_get_int(child, &ttl);
+            dnsttl = TIME_T_TO_CDTIME_T(ttl);
+        }
         else
         {
             ERROR("write_tsdb plugin: Invalid configuration "

From f15948ab1c8801d428b72ade95e6d38c9945d50d Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Wed, 14 Oct 2015 17:25:13 +0100
Subject: [PATCH 10/12] Bugfix on write_tsdb configuration parser

---
 src/write_tsdb.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 11df3fd..6566fe3 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -980,7 +980,7 @@ static int wt_config(oconfig_item_t *ci)
 
         if (strcasecmp("Node", child->key) == 0)
             wt_config_tsd(child);
-        if (strcasecmp("DNS_Cache_TTL", child->key) == 0)
+        else if (strcasecmp("DNS_Cache_TTL", child->key) == 0)
         {
             int ttl;
             cf_util_get_int(child, &ttl);

From d3681238304204a90ed40de06e4d55b6bc098172 Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Mon, 26 Oct 2015 16:59:45 +0000
Subject: [PATCH 11/12] write_tsdb : Add a random TTL before querying the DNS
 again

---
 src/collectd.conf.pod | 15 +++++++++-
 src/write_tsdb.c      | 77 +++++++++++++++++++++++++++++++++++++++++++++++----
 2 files changed, 85 insertions(+), 7 deletions(-)

diff --git a/src/collectd.conf.pod b/src/collectd.conf.pod
index c314c27..69147b2 100644
--- a/src/collectd.conf.pod
+++ b/src/collectd.conf.pod
@@ -7158,6 +7158,7 @@ Synopsis:
 
  <Plugin write_tsdb>
    DNS_Cache_TTL 60
+   DNS_Random_Cache_TTL 60
    <Node "example">
      Host "tsd-1.my.domain"
      Port "4242"
@@ -7174,10 +7175,22 @@ Global directives are:
 
 =item B<DNS_Cache_TTL> I<ttl>
 
+=item B<DNS_Random_Cache_TTL> I<ttl>
+
 When Collectd connects to a TSDB node, it will request the DNS. This can become
 a problem is the TSDN node is unavailable or badly configured because Collected
 will request DNS in order to reconnect for every metric, which can flood your DNS.
-So you can cache the last value for C<ttl> seconds (default: 60s).
+So you can cache the last value for C<ttl> seconds (default: 600s e.g; 10 min).
+
+You can also define a random ttl. This prevents all your Collectd servers to
+request the DNS at the same time when the connection fails. Default value is
+15 * the write_tsdb interval (or the global interval if write_tsdb interval is not
+defined).
+
+Note : if the DNS resolution has already been successful, if the socket closes,
+the plugin will try to reconnect as soon as possible with the cached information.
+DNS is queried only when the socket is closed for a long time (DNS_Cache_TTL + 
+DNS_Random_Cache_TTL)
 
 =back
 
diff --git a/src/write_tsdb.c b/src/write_tsdb.c
index 6566fe3..bdeac37 100644
--- a/src/write_tsdb.c
+++ b/src/write_tsdb.c
@@ -156,6 +156,21 @@
 # define WT_SEND_BUF_SIZE 1428
 #endif
 
+/* Default configuration */
+
+/* WRITE_TSDB_DEFAULT_DNS_TTL is the time we keep the dns cached info
+ * (seconds)
+ */
+#define WRITE_TSDB_DEFAULT_DNS_TTL 600
+
+/* WRITE_TSDB_DEFAULT_DNS_RANDOM_TTL helps define the max random
+ * time we keep the dns cached info :
+ * min = 0
+ * max = WRITE_TSDB_DEFAULT_DNS_RANDOM_TTL * get_plugin_interval()
+ */
+#define WRITE_TSDB_DEFAULT_DNS_RANDOM_TTL 15
+
+
 /* Meta data definitions about tsdb tags */
 #define TSDB_TAG_PLUGIN 0
 #define TSDB_TAG_PLUGININSTANCE 1
@@ -194,9 +209,13 @@ struct wt_callback
     pthread_mutex_t send_lock;
 
     _Bool    connect_failed_log_enabled;
+    int      connect_dns_failed_attempts_remaining;
+    cdtime_t next_random_ttl;
 };
 
-static cdtime_t dnsttl = TIME_T_TO_CDTIME_T(60);
+static cdtime_t dnsttl = TIME_T_TO_CDTIME_T(WRITE_TSDB_DEFAULT_DNS_TTL);
+static double dnsrandomttl = .0;
+static _Bool use_dnsrandomttl = 0;
 
 
 /*
@@ -262,6 +281,15 @@ static int wt_flush_nolock(cdtime_t timeout, struct wt_callback *cb)
     return status;
 }
 
+static cdtime_t new_random_ttl()
+{
+    time_t ttl = 0;
+    if(use_dnsrandomttl) {
+        ttl = (time_t)(dnsrandomttl * ((double) random ()) / (((double) RAND_MAX) + 1.0));
+    }
+    return TIME_T_TO_CDTIME_T(ttl);
+}
+
 static int wt_callback_init(struct wt_callback *cb)
 {
     struct addrinfo *ai_ptr;
@@ -275,10 +303,25 @@ static int wt_callback_init(struct wt_callback *cb)
         return 0;
 
     now = cdtime();
-    if ((cb->sock_info_last_update + dnsttl) < now) {
-        if(cb->sock_info) {
-            freeaddrinfo(cb->sock_info);
-            cb->sock_info = NULL;
+    if(cb->sock_info) {
+        /* When we are here, we still have the IP in cache.
+         * If we have remaining attempts without calling the DNS, we update the
+         * last_update date so we keep the info until next time.
+         * If there is no more attempts, we need to flush the cache.
+         */
+
+        if ((cb->sock_info_last_update + dnsttl + cb->next_random_ttl) < now) {
+            cb->next_random_ttl = new_random_ttl();
+            if(cb->connect_dns_failed_attempts_remaining > 0) {
+                /* Warning : this is run under send_lock mutex. 
+                 * This is why we do not use another mutex here.
+                 * */
+                cb->sock_info_last_update = now;
+                cb->connect_dns_failed_attempts_remaining-- ;
+            } else {
+                freeaddrinfo(cb->sock_info);
+                cb->sock_info = NULL;
+            }
         }
     }
 
@@ -292,13 +335,14 @@ static int wt_callback_init(struct wt_callback *cb)
         ai_hints.ai_family   = AF_UNSPEC;
         ai_hints.ai_socktype = SOCK_STREAM;
 
-        if ((cb->sock_info_last_update + dnsttl) >= now) {
+        if ((cb->sock_info_last_update + dnsttl + cb->next_random_ttl) >= now) {
                 DEBUG("write_tsdb plugin: too many getaddrinfo (%s, %s) failures",
                         node, service);
             return(-1);
         }
 
         cb->sock_info_last_update = now;
+        cb->next_random_ttl = new_random_ttl();
         status = getaddrinfo(node, service, &ai_hints, &(cb->sock_info));
         if (status != 0)
         {
@@ -350,6 +394,7 @@ static int wt_callback_init(struct wt_callback *cb)
         WARNING("write_tsdb plugin: Connecting to %s:%s succeeded.",node, service);
         cb->connect_failed_log_enabled = 1;
     }
+    cb->connect_dns_failed_attempts_remaining = 1;
     wt_reset_buffer(cb);
 
     return 0;
@@ -931,6 +976,8 @@ static int wt_config_tsd(oconfig_item_t *ci)
     cb->host_tags = NULL;
     cb->store_rates = 0;
     cb->connect_failed_log_enabled = 1;
+    cb->connect_dns_failed_attempts_remaining = 0;
+    cb->next_random_ttl = new_random_ttl();
 
     pthread_mutex_init (&cb->send_lock, NULL);
 
@@ -973,6 +1020,7 @@ static int wt_config_tsd(oconfig_item_t *ci)
 static int wt_config(oconfig_item_t *ci)
 {
     int i;
+    _Bool config_random_ttl = 0;
 
     for (i = 0; i < ci->children_num; i++)
     {
@@ -986,6 +1034,18 @@ static int wt_config(oconfig_item_t *ci)
             cf_util_get_int(child, &ttl);
             dnsttl = TIME_T_TO_CDTIME_T(ttl);
         }
+        else if (strcasecmp("DNS_Random_Cache_TTL", child->key) == 0)
+        {
+            int ttl;
+            cf_util_get_int(child, &ttl);
+            config_random_ttl = 1;
+            if(ttl) {
+                dnsrandomttl = (double)ttl;
+                use_dnsrandomttl = 1;
+            } else {
+                use_dnsrandomttl = 0;
+            }
+        }
         else
         {
             ERROR("write_tsdb plugin: Invalid configuration "
@@ -993,6 +1053,11 @@ static int wt_config(oconfig_item_t *ci)
         }
     }
 
+    if(! config_random_ttl ) {
+        use_dnsrandomttl = 1;
+        dnsrandomttl = CDTIME_T_TO_DOUBLE(WRITE_TSDB_DEFAULT_DNS_RANDOM_TTL * plugin_get_interval());
+    }
+
     return 0;
 }
 

From a89fc9296186de14cc308e18adae56c7777bae0e Mon Sep 17 00:00:00 2001
From: Yves Mettier <ymettier@free.fr>
Date: Thu, 12 Nov 2015 10:31:38 +0000
Subject: [PATCH 12/12] restores support for TypeInstance in ts_create()

---
 src/target_set.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/target_set.c b/src/target_set.c
index 5e9d087..da2d307 100644
--- a/src/target_set.c
+++ b/src/target_set.c
@@ -177,6 +177,9 @@ static int ts_create (const oconfig_item_t *ci, void **user_data) /* {{{ */
       status = ts_config_add_string (&data->type, child,
           /* may be empty = */ 0);
 #endif
+    else if (strcasecmp ("TypeInstance", child->key) == 0)
+      status = ts_config_add_string (&data->type_instance, child,
+          /* may be empty = */ 1);
     else if (strcasecmp ("MetaDataSet", child->key) == 0)
       status = ts_config_add_meta (&data->meta, child,
           /* may be empty = */ 1);
